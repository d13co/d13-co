<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Implementing an on-chain VRF shuffle for EXA Lootbox Reveals | D13.co</title>
<meta name=keywords content><meta name=description content="Discussing challenges and considerations in implementing a fair VRF-backed shuffle for the EXA Lootbox rewards program on Algorand"><meta name=author content="Bit @ D13.co"><link rel=canonical href=https://d13.co/posts/implementing-on-chain-vrf-shuffle-for-exa-lootbox-reveals/><link crossorigin=anonymous href=/assets/css/stylesheet.4d47a558fed7688229f8bb73344ccfcd4003dac666a96a34cc665d38ad5f6ec8.css integrity="sha256-TUelWP7XaIIp+LtzNEzPzUAD2sZmqWo0zGZdOK1fbsg=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script><link rel=icon href=https://d13.co/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=16x16 href=https://d13.co/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=https://d13.co/%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=https://d13.co/%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=https://d13.co/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://d13.co/posts/implementing-on-chain-vrf-shuffle-for-exa-lootbox-reveals/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="Implementing an on-chain VRF shuffle for EXA Lootbox Reveals"><meta property="og:description" content="Discussing challenges and considerations in implementing a fair VRF-backed shuffle for the EXA Lootbox rewards program on Algorand"><meta property="og:type" content="article"><meta property="og:url" content="https://d13.co/posts/implementing-on-chain-vrf-shuffle-for-exa-lootbox-reveals/"><meta property="og:image" content="https://d13.co/dice.jpg"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-08-28T18:58:00+03:00"><meta property="article:modified_time" content="2023-08-28T18:58:00+03:00"><meta property="og:site_name" content="D13.co"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://d13.co/dice.jpg"><meta name=twitter:title content="Implementing an on-chain VRF shuffle for EXA Lootbox Reveals"><meta name=twitter:description content="Discussing challenges and considerations in implementing a fair VRF-backed shuffle for the EXA Lootbox rewards program on Algorand"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://d13.co/posts/"},{"@type":"ListItem","position":2,"name":"Implementing an on-chain VRF shuffle for EXA Lootbox Reveals","item":"https://d13.co/posts/implementing-on-chain-vrf-shuffle-for-exa-lootbox-reveals/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Implementing an on-chain VRF shuffle for EXA Lootbox Reveals","name":"Implementing an on-chain VRF shuffle for EXA Lootbox Reveals","description":"Discussing challenges and considerations in implementing a fair VRF-backed shuffle for the EXA Lootbox rewards program on Algorand","keywords":[],"articleBody":"Following a brief partnership during CupStakes - where EXA.market was our official secondary marketplace - they commissioned me to implement the smart contracts that would power their rewards program.\nAs a new marketplace in the Algorand ecosystem, EXA wanted to incentivize users to trade on their platform. Users were rewarded with “Lootbox” NFTs for using the platform.\nAfter the lootboxes were distributed, we revealed that there were two more kinds of lootbox users could get. By merging 3 of their original (level 1) lootboxes they could get a level 2 lootbox, and by merging 3 of their level 2 lootboxes they would get a level 3 lootbox. This “merge” was performed by the first smart contract I developed for EXA.\nLootbox levels The mechanics of the higher level lootbox were not explicitly outlined at the time, but the implication was:\nYou would get fewer prizes (1 prize per lootbox) It would somehow be better than keeping level 1 lootboxes (one would hope) Users who took this leap of faith would indeed be rewarded. A few minutes before this article was published, the higher level lootboxes mechanics were announced:\nLevel 2 (L2) lootbox: guaranteed top 25% prize (at the time of the draw) Level 3 (L3) lootbox: guaranteed top 6.25% prize (at the time of the draw) Both L2s and L3s guarantee better odds at a top prize than the sum of their parts. An L3, for example, has 100% chance of getting a top 6.25% prize, whereas its individual ingredients (9x L1 lootboxes) have a cumulative ~56% chance of achieving the same.\nRevealing requirements The reveal contract’s job in a nutshell is “accept lootbox, send back prize”. Its requirements seem simple enough:\n(when created) accept an arbitrary number of prizes (represented as individual NFTs) ranked by their rarity (when launched) swap a user-provided lootbox for a randomly-chosen prize NFT adapted to the lootbox level (see above for guarantees), and provably fair Let’s start from the last one - “provably fair”.\nVerifiable Randomness In web2, you have to trust the operators of a lottery that the outcome was fairly determined, but in web3 - and on Algorand specifically - we can do better than that. After all, trustless execution is a big part of the appeal of blockchain.\nIn this case, we wanted to be able to come up with a system that could be proven to be fair. I hold a few lootboxes myself, so the challenge is to make a system that I can not game, even if I both developed and operated it.\nWe accomplished this by utilizing Verifiable Randomness.\nWait a sec You can not generate instant randomness on the Algorand blockchain - or any blockchain, to the extent of my knowledge. In an instant-randomness blockchain world, if someone has a lootbox (which I do) and runs a node (which I do) they could choose to submit the transactions only when it is favorable to them, which would break the system.\nInstead you have to commit to a future value. The Algorand Randomness Beacon was developed by the Foundation with Applied Blockchain. To use it properly, you need to transact in two stages.\nFirst, you commit to using the result of the Beacon contract at a future block. Then, after that block has elapsed, you can read the random value from the beacon smart contract. The beacon’s value is guaranteed to be immune from compromise even from its operators, as the beacon contract will accept the random value (“proof”) only if:\n1/ The correct private key was used to create it, and 2/ the correct thing was signed This value is submitted to the Beacon contract by an off-chain service, and happens every 8 rounds. The “correct thing being signed” in the beacon’s case is the seed of an Algorand block, which can’t be arbitrarily chosen by anyone, nor is it known ahead of time. If the right key is used but the wrong value is signed, the beacon smart contract will reject it.\nA bit faster please If we rely on the Algorand Randomness Beacon, the worst-case scenario wait-time for randomness works out to be 11 rounds*, which is about 36 seconds with the current version of the Algorand protocol.\n* 7 to get to the next block that randomness will be published for, another 2 for the off-chain service to publish, another 2 for our transaction to go through.\nThat is OK, and I relied on this method for the execution of the CupStakes draws, but in this case I wanted to see if we can do better than that.\nWhat’s in a beacon? The essence of the Randomness beacon is a smart contract that uses the vrf_verify opcode to verify that the value submitted to it (by the off-chain service) matches the expected signature of the pre-agreed-upon value (block seed for round N.)\nAll of these components were available to us, so we opted to use the exact same approach as the VRF beacon, except operated by ourselves, and on-demand. The extra effort to do this means we can have fixed-time reveals of exactly 4 blocks. The reveal process is:\nAt round 1000, the user sends their lootbox. We commit to execute based on the block seed of round 1000 + 2 = 1002 At round 1002 (+6.6 sec), our off-chain service reads the block seed, creates a VRF signature (or “proof”) with a specific key that the Reveal contract expects. At round 1004 (+13.2 sec), our backend can call the reveal contract to execute the reveal. The VRF signature is submitted, verified by the contract \u0026 the prize selection is made according to it. This approach is:\nfair: we can’t influence the outcome, as we cannot predict a future block seed predictably fast: our users will know the outcome of their reveal in 13.2 seconds The potential danger of this approach is the off-chain service failing to submit the reveal transaction. For this reason we have two different operators (myself and EXA) running two completely independent backends that watch the chain and execute reveals when they are spotted.\nWhat if it fails anyway? I am confident that the redundant backends will execute the reveals on-time, but still, when designing a smart contract you need to account for all eventualities. One of those is that all backends were offline for a long enough time that the block seed was “forgotten” by the network (from a smart contract, you can only see the block seed of the past 1000 blocks or so.)\nFor this unlikely scenario, reveals can be rescheduled if they expire: if a reveal was scheduled for more than 1000 rounds before the current round, then it can’t be executed, so it is rescheduled for 2 rounds in the future.\nThis, however, would leave open an attack vector if there is a solo operator of this service with stake in the game. If, say, I exclusively operated those backends, I could calculate the outcome for my own lootboxes when the reveal rounds were reached, and then just choose not to submit the reveal, wait for it to expire, and reschedule it - rinse and repeat until I win the top prize. This was another factor in deciding to run the backends from two different operators - both myself and EXA.\nDynamic prize pool A challenge in dealing with randomness on-chain (and generally) is ensuring that you are not introducing bias when mapping your uniform randomness to your choice space.\nLet’s assume for the sake of this example that the randomness value we get is between 0 and 7.\nIf our number of choices is a power of two, we can just take the remainder of the division (randomness/total_choices). With 4 possible choices, this would look like:\nRandomness -\u003e choice 0 -\u003e 0 1 -\u003e 1 2 -\u003e 2 3 -\u003e 3 4 -\u003e 0 5 -\u003e 1 6 -\u003e 2 7 -\u003e 3 This works great! We did not introduce any bias - each choice is equally likely.\nWhat if we have 6 choices to make, though?\nRandomness -\u003e choice 0 -\u003e 0 1 -\u003e 1 2 -\u003e 2 3 -\u003e 3 4 -\u003e 4 5 -\u003e 5 6 -\u003e 0 7 -\u003e 1 Here we are producing twice as many 0s and 1s as the other choices, so while the input randomness was uniform, the output is skewed to favor outcomes 0 and 1.\nIn real life On-chain, the randomness we get is 32 bytes, which is a number between 0 and 2256 -1. There are a few different ways to accomplish mapping this to an arbitrary space, but a fairly simple one is to take “chunks” out of the randomness and keep trying to fit it into your choice space. If it doesn’t fit, keep taking chunks until one does.\nSo if we had to make a choice out of 200 choices, we would take a byte-sized chunkheh and see if it falls within 0-199. If yes, that is our result. If not, take the next byte and try again. As a byte is 256 possible values, each “chunk” has a 78% chance of fitting in to 0-199. This approach can fail if the number is just-right (/wrong), but in this example the odds of that are 0.0000000000000000000755% - and with our actual lootbox numbers it is similarly unlikely that it will happen.\nI modeled this approach in Javascript, tested it (tens of millions of samples), then wrote it in pyTEAL. Both the individual function that produces this, and the reveal contract overall, were extensively tested to ensure that the averages are in the expected ranges.\nFor L2 and L3 lootboxes, the choice is made across the entire prize pool space, and then divided by 4 or 16 respectively.\nLarge prize pool The final bit of complexity had to do with the number of prizes. The exact number was not known during the initial phases of development, but it was estimated to be in the thousands. The actual number of prizes after the merging phase was concluded was 4,015. On an Algorand smart contract, this leaves box storage as the only viable option to store the prize pool.\nEven after optimizing a bit (by using 4 bytes to store each asset ID instead of the normal 8) - that still gives us a prize pool box size of 16KB. While boxes can be up to 32KB in total size, things are generally constrained when operating with large boxes: a single transaction cannot read a box that large, so you need multiple to increase your “budget”.\nAnother delightful (but reasonable) surprise is that the maximum length of a byte sequence you can store in memory on the AVM is 4KB. So if you need to remove a prize from the start of a 16KB box, you need to put some elbow grease in it.\nAs Boxes are fairly new, there are no data structures that I am aware of that can utilize them, so you have to write your own. The prize pool is stored as a list of 4015 concatenated uint32 values, and the operations to push to this list, or splice it, had to be coded with care (especially considering the aforementioned 4KB limitation.)\nWrapping up All in all, this engagement was really interesting and even challenging at times. I am satisfied with the results so far \u0026 hope that the reveal phase - which is due to start within the hour after this article is published - will go smoothly for all users.\nAnd who knows - we may be seeing more of this VRF shuffle method beyond the lootbox reveals.\nThe reveal contract ID is 1177117711 on Mainnet.\nFor any questions you can hit me up on Twitter or by Email.\n","wordCount":"1963","inLanguage":"en","image":"https://d13.co/dice.jpg","datePublished":"2023-08-28T18:58:00+03:00","dateModified":"2023-08-28T18:58:00+03:00","author":{"@type":"Person","name":"Bit @ D13.co"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://d13.co/posts/implementing-on-chain-vrf-shuffle-for-exa-lootbox-reveals/"},"publisher":{"@type":"Organization","name":"D13.co","logo":{"@type":"ImageObject","url":"https://d13.co/%3Clink%20/%20abs%20url%3E"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://d13.co/ accesskey=h title="  (Alt + H)"><img src=https://d13.co/images/logo-7-green-128.png alt=logo aria-label=logo height=48></a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button><ul class=lang-switch><li>|</li></ul></div></div><ul id=menu></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://d13.co/>Home</a>&nbsp;»&nbsp;<a href=https://d13.co/posts/>Posts</a></div><h1 class=post-title>Implementing an on-chain VRF shuffle for EXA Lootbox Reveals</h1><div class=post-description>Discussing challenges and considerations in implementing a fair VRF-backed shuffle for the EXA Lootbox rewards program on Algorand</div><div class=post-meta>&lt;span title='2023-08-28 18:58:00 +0300 +0300'>August 28, 2023&lt;/span>&amp;nbsp;·&amp;nbsp;10 min&amp;nbsp;·&amp;nbsp;1963 words&amp;nbsp;·&amp;nbsp;Bit @ D13.co&nbsp;|&nbsp;<a href=https://github.com/d13co/d13.co/tree/main/content/posts/implementing-on-chain-vrf-shuffle-for-exa-lootbox-reveals/index.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><figure class=entry-cover><img loading=lazy srcset="https://d13.co/posts/implementing-on-chain-vrf-shuffle-for-exa-lootbox-reveals/dice_hu11264906487929191841.jpg 360w ,https://d13.co/posts/implementing-on-chain-vrf-shuffle-for-exa-lootbox-reveals/dice_hu8725966399403997557.jpg 480w ,https://d13.co/posts/implementing-on-chain-vrf-shuffle-for-exa-lootbox-reveals/dice_hu11665586576609616760.jpg 720w ,https://d13.co/posts/implementing-on-chain-vrf-shuffle-for-exa-lootbox-reveals/dice_hu7070602615703636291.jpg 1080w ,https://d13.co/posts/implementing-on-chain-vrf-shuffle-for-exa-lootbox-reveals/dice_hu581961164308120410.jpg 1500w ,https://d13.co/posts/implementing-on-chain-vrf-shuffle-for-exa-lootbox-reveals/dice.jpg 1920w" sizes="(min-width: 768px) 720px, 100vw" src=https://d13.co/posts/implementing-on-chain-vrf-shuffle-for-exa-lootbox-reveals/dice.jpg alt width=1920 height=1079></figure><div class=post-content><p>Following a brief partnership during <a href=https://cupstakes.world>CupStakes</a> - where <a href=https://exa.market/>EXA.market</a> was our official secondary marketplace - they commissioned me to implement the smart contracts that would power their <a href=https://exa.market/rewards>rewards program</a>.</p><p>As a new marketplace in the Algorand ecosystem, EXA wanted to incentivize users to trade on their platform. Users were rewarded with <a href=https://explorer.perawallet.app/assets/1003527093/>&ldquo;Lootbox&rdquo; NFTs</a> for using the platform.</p><p>After the lootboxes were distributed, we revealed that there were two more kinds of lootbox users could get. By merging 3 of their original (level 1) lootboxes they could get a <a href=https://explorer.perawallet.app/assets/1108385957/>level 2 lootbox</a>, and by merging 3 of their level 2 lootboxes they would get a <a href=https://explorer.perawallet.app/assets/1108387538/>level 3 lootbox</a>. This &ldquo;merge&rdquo; was performed by the first smart contract I developed for EXA.</p><h2 id=lootbox-levels>Lootbox levels<a hidden class=anchor aria-hidden=true href=#lootbox-levels>#</a></h2><p>The mechanics of the higher level lootbox were not explicitly outlined at the time, but the implication was:</p><ul><li>You would get fewer prizes (1 prize per lootbox)</li><li>It would somehow be better than keeping level 1 lootboxes (one would hope)</li></ul><p>Users who took this leap of faith would indeed be rewarded. A few minutes before this article was published, the higher level lootboxes mechanics were announced:</p><ul><li>Level 2 (L2) lootbox: guaranteed top 25% prize (at the time of the draw)</li><li>Level 3 (L3) lootbox: guaranteed top 6.25% prize (at the time of the draw)</li></ul><p>Both L2s and L3s guarantee better odds at a top prize than the sum of their parts. An L3, for example, has 100% chance of getting a top 6.25% prize, whereas its individual ingredients (9x L1 lootboxes) have a cumulative ~56% chance of achieving the same.</p><h2 id=revealing-requirements>Revealing requirements<a hidden class=anchor aria-hidden=true href=#revealing-requirements>#</a></h2><p>The reveal contract&rsquo;s job in a nutshell is &ldquo;accept lootbox, send back prize&rdquo;. Its requirements seem simple enough:</p><ul><li>(when created) accept an arbitrary number of prizes (represented as individual NFTs) ranked by their rarity</li><li>(when launched) swap a user-provided lootbox for a randomly-chosen prize NFT<ul><li>adapted to the lootbox level (see above for guarantees), and</li><li>provably fair</li></ul></li></ul><p>Let&rsquo;s start from the last one - &ldquo;provably fair&rdquo;.</p><h2 id=verifiable-randomness>Verifiable Randomness<a hidden class=anchor aria-hidden=true href=#verifiable-randomness>#</a></h2><p>In web2, you have to trust the operators of a lottery that the outcome was fairly determined, but in web3 - and on Algorand specifically - we can do better than that. After all, trustless execution is a big part of the appeal of blockchain.</p><p>In this case, we wanted to be able to come up with a system that could be proven to be fair. I hold a few lootboxes myself, so the challenge is to make a system that I can not game, even if I both developed <em>and</em> operated it.</p><p>We accomplished this by utilizing <a href="https://developer.algorand.org/articles/randomness-on-algorand/?from_query=verifiable%20randomness">Verifiable Randomness</a>.</p><h4 id=wait-a-sec>Wait a sec<a hidden class=anchor aria-hidden=true href=#wait-a-sec>#</a></h4><p>You can not generate instant randomness on the Algorand blockchain - or any blockchain, to the extent of my knowledge. In an instant-randomness blockchain world, if someone has a lootbox (which I do) and runs a node (which I do) they could choose to submit the transactions only when it is favorable to them, which would break the system.</p><p>Instead you have to commit to a future value. The <a href=https://developer.algorand.org/articles/usage-and-best-practices-for-randomness-beacon/>Algorand Randomness Beacon</a> was developed by the Foundation with <a href=https://appliedblockchain.com/>Applied Blockchain</a>. To use it properly, you need to transact in two stages.</p><p>First, you commit to using the result of the Beacon contract at a future block. Then, after that block has elapsed, you can read the random value from the beacon smart contract. The beacon&rsquo;s value is guaranteed to be immune from compromise even from its operators, as the beacon contract will accept the random value (&ldquo;proof&rdquo;) only if:</p><ul><li>1/ The correct private key was used to create it, and</li><li>2/ the correct thing was signed</li></ul><p>This value is submitted to the Beacon contract by an off-chain service, and happens every 8 rounds. The &ldquo;correct thing being signed&rdquo; in the beacon&rsquo;s case is the seed of an Algorand block, which can&rsquo;t be arbitrarily chosen by anyone, nor is it known ahead of time. If the right key is used but the wrong value is signed, the beacon smart contract will reject it.</p><h4 id=a-bit-faster-please>A bit faster please<a hidden class=anchor aria-hidden=true href=#a-bit-faster-please>#</a></h4><p>If we rely on the Algorand Randomness Beacon, the worst-case scenario wait-time for randomness works out to be 11 rounds*, which is about 36 seconds with the current version of the Algorand protocol.</p><p><em>* 7 to get to the next block that randomness will be published for, another 2 for the off-chain service to publish, another 2 for our transaction to go through.</em></p><p>That is OK, and I relied on this method for the execution of the <a href=https://cupstakes.world>CupStakes</a> draws, but in this case I wanted to see if we can do better than that.</p><h4 id=whats-in-a-beacon>What&rsquo;s in a beacon?<a hidden class=anchor aria-hidden=true href=#whats-in-a-beacon>#</a></h4><p>The essence of the Randomness beacon is a smart contract that uses the <code>vrf_verify</code> <a href=https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/#vrf_verify>opcode</a> to verify that the value submitted to it (by the off-chain service) matches the expected signature of the pre-agreed-upon value (block seed for round N.)</p><p>All of these components were available to us, so we opted to use the exact same approach as the VRF beacon, except operated by ourselves, and on-demand. The extra effort to do this means we can have fixed-time reveals of exactly 4 blocks. The reveal process is:</p><ul><li>At round 1000, the user sends their lootbox. We commit to execute based on the block seed of round 1000 + 2 = 1002</li><li>At round 1002 (+6.6 sec), our off-chain service reads the block seed, creates a VRF signature (or &ldquo;proof&rdquo;) with a specific key that the Reveal contract expects.</li><li>At round 1004 (+13.2 sec), our backend can call the reveal contract to execute the reveal. The VRF signature is submitted, verified by the contract & the prize selection is made according to it.</li></ul><p>This approach is:</p><ul><li>fair: we can&rsquo;t influence the outcome, as we cannot predict a future block seed</li><li>predictably fast: our users will know the outcome of their reveal in 13.2 seconds</li></ul><p>The potential danger of this approach is the off-chain service failing to submit the reveal transaction. For this reason we have two different operators (myself and EXA) running two completely independent backends that watch the chain and execute reveals when they are spotted.</p><h4 id=what-if-it-fails-anyway>What if it fails anyway?<a hidden class=anchor aria-hidden=true href=#what-if-it-fails-anyway>#</a></h4><p>I am confident that the redundant backends will execute the reveals on-time, but still, when designing a smart contract you need to account for all eventualities. One of those is that all backends were offline for a long enough time that the block seed was &ldquo;forgotten&rdquo; by the network (from a smart contract, you can only see the block seed of the past 1000 blocks or so.)</p><p>For this unlikely scenario, reveals can be rescheduled if they expire: if a reveal was scheduled for more than 1000 rounds before the current round, then it can&rsquo;t be executed, so it is rescheduled for 2 rounds in the future.</p><p>This, however, would leave open an attack vector if there is a solo operator of this service with stake in the game. If, say, I exclusively operated those backends, I could calculate the outcome for my own lootboxes when the reveal rounds were reached, and then just choose not to submit the reveal, wait for it to expire, and reschedule it - rinse and repeat until I win the top prize. This was another factor in deciding to run the backends from two different operators - both myself and EXA.</p><h2 id=dynamic-prize-pool>Dynamic prize pool<a hidden class=anchor aria-hidden=true href=#dynamic-prize-pool>#</a></h2><p>A challenge in dealing with randomness on-chain (and generally) is ensuring that you are not introducing bias when mapping your uniform randomness to your choice space.</p><p>Let&rsquo;s assume for the sake of this example that the randomness value we get is between 0 and 7.</p><p>If our number of choices is a power of two, we can just take the remainder of the division (randomness/total_choices). With 4 possible choices, this would look like:</p><pre tabindex=0><code>Randomness -&gt; choice
0 -&gt; 0
1 -&gt; 1
2 -&gt; 2
3 -&gt; 3
4 -&gt; 0
5 -&gt; 1
6 -&gt; 2
7 -&gt; 3
</code></pre><p>This works great! We did not introduce any bias - each choice is equally likely.</p><p>What if we have 6 choices to make, though?</p><pre tabindex=0><code>Randomness -&gt; choice
0 -&gt; 0
1 -&gt; 1
2 -&gt; 2
3 -&gt; 3
4 -&gt; 4
5 -&gt; 5
6 -&gt; 0
7 -&gt; 1
</code></pre><p>Here we are producing twice as many 0s and 1s as the other choices, so while the input randomness was uniform, the output is skewed to favor outcomes 0 and 1.</p><h4 id=in-real-life>In real life<a hidden class=anchor aria-hidden=true href=#in-real-life>#</a></h4><p>On-chain, the randomness we get is 32 bytes, which is a number between 0 and 2<sup>256</sup>
-1. There are a few different ways to accomplish mapping this to an arbitrary space, but a fairly simple one is to take &ldquo;chunks&rdquo; out of the randomness and keep trying to fit it into your choice space. If it doesn&rsquo;t fit, keep taking chunks until one does.</p><p>So if we had to make a choice out of 200 choices, we would take a byte-sized chunk<sup>heh</sup>
and see if it falls within 0-199. If yes, that is our result. If not, take the next byte and try again. As a byte is 256 possible values, each &ldquo;chunk&rdquo; has a 78% chance of fitting in to 0-199. This approach can fail if the number is just-right (/wrong), but in this example the odds of that are 0.0000000000000000000755% - and with our actual lootbox numbers it is similarly unlikely that it will happen.</p><p>I modeled this approach in Javascript, tested it (tens of millions of samples), then wrote it in pyTEAL. Both the individual function that produces this, and the reveal contract overall, were extensively tested to ensure that the averages are in the expected ranges.</p><p>For L2 and L3 lootboxes, the choice is made across the entire prize pool space, and then divided by 4 or 16 respectively.</p><h2 id=large-prize-pool>Large prize pool<a hidden class=anchor aria-hidden=true href=#large-prize-pool>#</a></h2><p>The final bit of complexity had to do with the number of prizes. The exact number was not known during the initial phases of development, but it was estimated to be in the thousands. The actual number of prizes after the merging phase was concluded was 4,015. On an Algorand smart contract, this leaves box storage as the only viable option to store the prize pool.</p><p>Even after optimizing a bit (by using 4 bytes to store each asset ID instead of the normal 8) - that still gives us a prize pool box size of 16KB. While boxes can be up to 32KB in total size, things are generally constrained when operating with large boxes: a single transaction cannot read a box that large, so you need multiple to increase your &ldquo;budget&rdquo;.</p><p>Another delightful (but reasonable) surprise is that the maximum length of a byte sequence you can store in memory on the AVM is 4KB. So if you need to remove a prize from the start of a 16KB box, you need to put some elbow grease in it.</p><p>As Boxes are fairly new, there are no data structures that I am aware of that can utilize them, so you have to write your own. The prize pool is stored as a list of 4015 concatenated uint32 values, and the operations to push to this list, or splice it, had to be coded with care (especially considering the aforementioned 4KB limitation.)</p><h2 id=wrapping-up>Wrapping up<a hidden class=anchor aria-hidden=true href=#wrapping-up>#</a></h2><p>All in all, this engagement was really interesting and even challenging at times. I am satisfied with the results so far & hope that the reveal phase - which is due to start within the hour after this article is published - will go smoothly for all users.</p><p>And who knows - we may be seeing more of this VRF shuffle method beyond the lootbox reveals.</p><hr><p>The reveal contract ID is <a href=https://allo.info/application/1177117711>1177117711</a> on Mainnet.</p><p>For any questions you can hit me up on <a href=https://twitter.com/d13_co>Twitter</a> or by <a href=mailto:bit@d13.co>Email</a>.</p></div><footer class=post-footer><ul class=post-tags></ul><nav class=paginav><a class=prev href=https://d13.co/posts/set-up-voi-participation-node/><span class=title>« Prev</span><br><span>Set Up Voi Participation Node on Ubuntu 22.04</span>
</a><a class=next href=https://d13.co/posts/redundant-participation-nodes-on-algorand/><span class=title>Next »</span><br><span>Redundant Participation Nodes on Algorand</span></a></nav><div class=share-buttons><a target=_blank rel="noopener noreferrer" aria-label="share Implementing an on-chain VRF shuffle for EXA Lootbox Reveals on twitter" href="https://twitter.com/intent/tweet/?text=Implementing%20an%20on-chain%20VRF%20shuffle%20for%20EXA%20Lootbox%20Reveals&amp;url=https%3a%2f%2fd13.co%2fposts%2fimplementing-on-chain-vrf-shuffle-for-exa-lootbox-reveals%2f&amp;hashtags="><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM195.519 424.544c135.939.0 210.268-112.643 210.268-210.268.0-3.218.0-6.437-.153-9.502 14.406-10.421 26.973-23.448 36.935-38.314-13.18 5.824-27.433 9.809-42.452 11.648 15.326-9.196 26.973-23.602 32.49-40.92-14.252 8.429-30.038 14.56-46.896 17.931-13.487-14.406-32.644-23.295-53.946-23.295-40.767.0-73.87 33.104-73.87 73.87.0 5.824.613 11.494 1.992 16.858-61.456-3.065-115.862-32.49-152.337-77.241-6.284 10.881-9.962 23.601-9.962 37.088.0 25.594 13.027 48.276 32.95 61.456-12.107-.307-23.448-3.678-33.41-9.196v.92c0 35.862 25.441 65.594 59.311 72.49-6.13 1.686-12.72 2.606-19.464 2.606-4.751.0-9.348-.46-13.946-1.38 9.349 29.426 36.628 50.728 68.965 51.341-25.287 19.771-57.164 31.571-91.8 31.571-5.977.0-11.801-.306-17.625-1.073 32.337 21.15 71.264 33.41 112.95 33.41z"/></svg>
</a><a target=_blank rel="noopener noreferrer" aria-label="share Implementing an on-chain VRF shuffle for EXA Lootbox Reveals on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fd13.co%2fposts%2fimplementing-on-chain-vrf-shuffle-for-exa-lootbox-reveals%2f&amp;title=Implementing%20an%20on-chain%20VRF%20shuffle%20for%20EXA%20Lootbox%20Reveals&amp;summary=Implementing%20an%20on-chain%20VRF%20shuffle%20for%20EXA%20Lootbox%20Reveals&amp;source=https%3a%2f%2fd13.co%2fposts%2fimplementing-on-chain-vrf-shuffle-for-exa-lootbox-reveals%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg>
</a><a target=_blank rel="noopener noreferrer" aria-label="share Implementing an on-chain VRF shuffle for EXA Lootbox Reveals on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fd13.co%2fposts%2fimplementing-on-chain-vrf-shuffle-for-exa-lootbox-reveals%2f&title=Implementing%20an%20on-chain%20VRF%20shuffle%20for%20EXA%20Lootbox%20Reveals"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg>
</a><a target=_blank rel="noopener noreferrer" aria-label="share Implementing an on-chain VRF shuffle for EXA Lootbox Reveals on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fd13.co%2fposts%2fimplementing-on-chain-vrf-shuffle-for-exa-lootbox-reveals%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg>
</a><a target=_blank rel="noopener noreferrer" aria-label="share Implementing an on-chain VRF shuffle for EXA Lootbox Reveals on whatsapp" href="https://api.whatsapp.com/send?text=Implementing%20an%20on-chain%20VRF%20shuffle%20for%20EXA%20Lootbox%20Reveals%20-%20https%3a%2f%2fd13.co%2fposts%2fimplementing-on-chain-vrf-shuffle-for-exa-lootbox-reveals%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg>
</a><a target=_blank rel="noopener noreferrer" aria-label="share Implementing an on-chain VRF shuffle for EXA Lootbox Reveals on telegram" href="https://telegram.me/share/url?text=Implementing%20an%20on-chain%20VRF%20shuffle%20for%20EXA%20Lootbox%20Reveals&amp;url=https%3a%2f%2fd13.co%2fposts%2fimplementing-on-chain-vrf-shuffle-for-exa-lootbox-reveals%2f"><svg viewBox="2 2 28 28"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></div></footer></article></main><footer class=footer><span>&copy; 2024 <a href=https://d13.co/>D13.co</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>